<node>
  <doctext>&lt;p&gt;This is just an attempt to make something slightly useful for [THE IRON NODER CHALLENGE] so the progress doesn't have to be tracked manually. Currently, this is only useful for &lt;strong&gt;checking&lt;/strong&gt; writeups; if I have time later, I'll put in something to generate HTML that can be copied into a writeup.&lt;/p&gt;
&lt;p&gt;(Note: this has not been tested for lag or really checked for security, so do not let normal users use this yet; it is currently only verified for admins.) (Note 2: The UI is pretty bad too (debug messages may appear).)&lt;/p&gt;
&lt;p&gt;&amp;mdash; [N-Wing], Sunday, November 16, 2008&lt;/p&gt;

[%
#constants
my $UID = getId($USER)||$HTMLVARS{'guest_user'}||0;
my $isGuest = ($UID==$HTMLVARS{'guest_user'} or !$UID);
my $isRoot = !$isGuest &amp;&amp; exists $HTMLVARS{group_gods}{$UID};
my $isCE = !$isGuest &amp;&amp; ($isRoot || exists $HTMLVARS{'group_content editors'}{$UID});

#return 'This is still barely started.' unless $UID==9740;
return 'Sorry, this is currently unavailable for public use. &lt;small&gt;([THE IRON NODER CHALLENGE])&lt;/small&gt;' unless $isRoot;



#if there are more iron noder things later, this section should be updated to select appropriate group
#	ironnoders	2008 November
my $groupTitle = 'ironnoders';
my @groupTypes = ('usergroup');

my $dateMinInc = '2008-11-01';
my $dateMaxExc = '2008-12-01';


my $ug = undef;
foreach(@groupTypes) {
	$ug = getNode($groupTitle, $_);
	last if defined $ug;
}

if(!defined $ug) {
	return 'Sorry; unable to find a list of iron noders.';
}
#return 'found group '.linkNode($ug);



#contains iron noder information
#	key is user node_id
#	value is light node ref
my %ironNoders;


my $str = '';
$str .= '&lt;ul&gt;
';

my $u;
my $ironID;
foreach $ironID (@{$$ug{group}}) {
	$u = getNodeById($ironID, 'light');

	if(!$u) {
		$str .= '(DEBUG: unable to get user ID '.$ironID.')';
		next;
	}

	$ironNoders{$ironID} = $u;

#	$str .= '&lt;li&gt;'.linkNode($u).'&lt;/li&gt;
#';

}


#writeup information setup
my $showWUs = 1;
my $dbh = undef;
my $qh = undef;
my $typeID = getId(getType('writeup')) || undef;
if($showWUs &amp;&amp; !$typeID) {
	$showWUs = 0;
	$str .= '(DEBUG: unable to get writeup type)';
}
if($showWUs) {
	$dbh = $DB-&gt;getDatabaseHandle();
	if(!$dbh) {
		undef $dbh;
		$showWUs=0;
		$str .= '(DEBUG: unable to connect to database for writeups)';
	}
}
if($showWUs &amp;&amp; (defined $dbh)) {
	$qh = $dbh-&gt;prepare('SELECT node_id,title,createtime FROM node WHERE type_nodetype='.$typeID.' AND author_user=? AND createtime&gt;=? AND createtime&lt;? ORDER BY node_id ASC');
#	$qh = $dbh-&gt;prepare('SELECT COUNT(*) FROM node WHERE type_nodetype='.$typeID.' AND author_user=? AND createtime&gt;=? AND createtime&lt;?');
	if(!$qh) {
		undef $qh;
		undef $dbh;
		$showWUs = 0;
		$str .= '(DEBUG: unable to construct query for writeups)';
	}
}




#all iron noders
#	key is what to sort by
#	value is light node ref
my %ironNodersBySortKey;
my $sortKey;
foreach(keys(%ironNoders)) {
	#sort by username (case insensitive), and break tie by appending something arbitrary but consistent
	$sortKey = lc($ironNoders{$_}-&gt;{title}) . $ironNoders{$_}-&gt;{node_id};
	#while(exists $ironNodersBySortKey{$sortKey}) { $sortKey .= '.'; }
	$ironNodersBySortKey{ $sortKey } = $ironNoders{$_};
}

my @displayOrder = sort(keys(%ironNodersBySortKey));
#TODO? maybe reverse half the time to not favor items? maybe randomly split list in half (so everyone has equal chance of being somewhere in list)

my $BIGNUMBER = 99999;
my $statTotalWU = 0;
my $statUserWU;
my $statMaxCount = -1;
my $statMinCount = $BIGNUMBER;
my $statMinCountPositive = $BIGNUMBER;

my $htmlListUser;

foreach $sortKey (@displayOrder) {
	$u = $ironNodersBySortKey{$sortKey};
	$ironID = getId($u);
	unless($ironID) {
		$str .= '(DEBUG: unable to get ID for '.htmlEncode($sortKey).')';
		next;
	}

	$htmlListUser = '';

	$htmlListUser .= '&lt;li&gt;';
	if($showWUs) { $htmlListUser .= '&lt;big&gt;'; };
	$htmlListUser .= linkNode($u);
	if($showWUs) { $htmlListUser .= '&lt;/big&gt;'; };

	if($showWUs) {
		$statUserWU = 0;

		$qh-&gt;execute(getId($u),$dateMinInc,$dateMaxExc);
		my @userWUs = ();
		while(my $r=$qh-&gt;fetchrow_hashref) {
			push(@userWUs, $r);
		}
		$qh-&gt;finish();
		$statUserWU = scalar(@userWUs);
		$htmlListUser .= ' (' . $statUserWU . ')';

		$htmlListUser .= '&lt;ol&gt;
';
		foreach(@userWUs) {
			$htmlListUser .= &quot;\t&lt;li&gt;&quot;;
			$htmlListUser .= linkNode($_-&gt;{node_id},encodeHTML($_-&gt;{title}));
			$htmlListUser .= '&lt;/li&gt;
';
		}
		$htmlListUser .= '&lt;/ol&gt;';


		#update stats
		$statTotalWU += $statUserWU;
		if($statUserWU &lt; $statMinCount) { $statMinCount = $statUserWU; }
		if(($statUserWU &lt; $statMinCountPositive) &amp;&amp; ($statUserWU&gt;0) ) { $statMinCountPositive = $statUserWU; }
		if($statUserWU &gt; $statMaxCount) { $statMaxCount = $statUserWU; }

	}

	$htmlListUser .= '&lt;/li&gt;
';


	$str .= $htmlListUser;

}

$str .= '&lt;/ul&gt;';


#statistics
#TODO: user with at least 1 writeup, users with required number of WUs
if($showWUs) {
	$str .= '&lt;p&gt;&lt;strong&gt;some statistics&lt;/strong&gt;:&lt;br /&gt;
';
	if($statMinCount!=$BIGNUMBER) {
		$str .= 'minimum: '.$statMinCount.'&lt;br /&gt;
';
	}
	if($statMinCountPositive!=$BIGNUMBER) {
		$str .= 'positive minimum: '.$statMinCountPositive.'&lt;br /&gt;
';
	}
	if($statMaxCount&gt;=0) {
		$str .= 'maximum: '.$statMaxCount.'&lt;br /&gt;
';
	}
	$str .= 'total writeups: '.$statTotalWU.'
&lt;/p&gt;';
}


return $str;
%]</doctext>
  <createtime>2008-11-16 05:48:21</createtime>
  <totalvotes>0</totalvotes>
  <node_id>1963731</node_id>
  <edittime>0000-00-00 00:00:00</edittime>
  <type_nodetype>13</type_nodetype>
  <document_id>1963731</document_id>
  <author_user>9740</author_user>
  <title>deprecated iron noder progress</title>
</node>
